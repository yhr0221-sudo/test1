#include <stdio.h>
#include<string.h>
// int main(void)
// {
// 3 장 포인터
// 주소는 변수가 할당된 메모리의 시작주소임. 이 주소를 알면 주소로도 변수의 공간이나 값을 사용할 수 있음.
// ex) int a =10; a의 주소를 100,101,102,104 라면 100을 호출해도 10이 나옴.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 주소 연산자
//     int a;
//     double b;
//     char c;
//     // %u(unsigned int) : 부호 없는 10진수 정수로 출력  / 사실 주소는 16진수로 출력됨 (0x7ffdf5b30c2c...이런형태) -> %p는 주소값을 16진수(hexadecimal) 형식으로 출력
//     printf("int형 변수의 주소 : %u\n",&a);      //&:주소 연산자 a:변수명,  
//     printf("double형 변수의 주소 : %p\n",&b);
//     printf("char형 변수의 주소 : %p\n",&c);

// //실행할 때 마다 주소가 바뀜 / 주소는 왜 16진수인가 ? -> 16진수는 2진수로 변환이 편하고 읽기 편함 -> 2진수라면 너무길어서 읽기힘듬.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 포인터와 간접 참조 연산자 : *
//     int a;      // 일반 변수 선언 - a라는 공간의 집을 생성
//     int *pa;    // 포인터 선언 (포인터 변수는 값이 아닌 주소를 받는 변수임.) - 주소를 적을 공간을 생성
//     printf("a 변수의 주소 : %u\n",&a);
//     printf("pa 변수의 주소 : %u\n",&pa);

//     pa = &a;    // 포인터에 a 의 주소 대입 / pa에는 주소만 넣음 그래서 &(주소연산자) a(변수명)을 써서 주소를 넣어줌 - pa에 a집의 주소를 적음
//     *pa = 10;   // 포인터로 변수 a에 10 대입 / *pa = 10; // pa가 가리키는 주소(&a)로 '이동'하여, 그 공간(a)에 10을 대입. // pa에 적힌 주소로 이동해 그 공간에 10을 넣음.
//                 //*pa는 변수 a 그 자체와 동일하게 취급됨.

//     printf("포인터로 a 값 출력 :%d\n",*pa);
//     printf("변수명으로 a 값 출력 : %d\n",a);

// // * 의 쓰임
// //      1. 선언할 때 (int *pa;)
// // 의미: 이 변수는 포인터 타입입니다.
// // * 가 변수 타입의 일부로 쓰입니다. pa라는 변수가 '주소'를 저장할 것임을 컴파일러에게 알립니다.
// //      2.사용할 때 (*pa = 10;)
// // 의미: 이 포인터가 가진 주소로 *이동(참조)*하세요.
// // * 가 연산자(Operator)로 쓰입니다. "주소값(pa)"을 "그 주소에 있는 실제 공간(*pa)"으로 변환시킵니다.


// //// 포인터를 사용하는 이유 ?
// // 1. C언어에서 함수는 기본적으로 그 값을 복사해오는데, 주소를 찾아 수정하면 원본 값을 수정 할 수 있기 때문에.

// // 2. 용량이 매우 큰 데이터를 함수에 전달하면, 그 용량 전체를 복사하므로 속도가 매우 느려짐. 하지만 포인터를 사용하면, 
// //    데이터가 저장된 '시작 주소'(8바이트짜리)만 함수에 넘겨주므로, 함수는 그 주소를 보고 원본을 찾아가서 작업합니다. 복사 시간이 매우 짧아짐.

// // 3. 코딩할 때 데이터가 몇 개 필요한지 모를 때, 미리 넉넉한 칸을 잡아두면 메모리 낭비가 됨. 이를 방지하기 위해서 사용

// // 4. (고급) 하드웨어에 직접 명령을 내릴 때(로보틱스나 임베디드에서 매우 중요.)
// //      특정 하드웨어(LED, 모터, 센서)는 컴퓨터 메모리의 '특정 고정 주소'에 연결되어 있습니다.
// //      예를 들어, "메모리 주소 0xFF0040에 숫자 1을 쓰면 LED가 켜진다"라는 하드웨어 규약이 있다면, 포인터는 이 작업을 수행할 유일한 방법.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ   

// // 여러가지 포인터 사용해보기
//     int a =10, b = 15, total;
//     double avg;
//     int *pa, *pb;  
//     int *pt= &total;
//     double *pg = &avg; // 가르키는 자료형에 맞게 포인터를 선언함 avg가 double이므로 *pg도 double가 됨.

//     pa = &a;
//     pb = &b;
//     *pt = *pa + *pb;
//     *pg = *pt/2.0;

//     printf(" 두 정수의 값 : %d, %d\n",*pa,*pb);
//     printf("두 정수의 합: %d\n",*pt);
//     printf("두 정수의 평균 : %.1f\n",*pg);

// 포인터 변수는 int(4바이트)로 선언해도 8바이트임. (가르키는 자료형과 상관없이 항상 첫 번째 주소만 저장함)
// int a[1000] -> 4x1000 = 4000바이트 이렇게 용량이 큰 값에 유용하게 쓰임(메모리를 효율적으로). 

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // const를 사용한 포인터
//     int a = 10, b = 20;
//     const int *pa = & a;  // const의미 : *pa = 20; (X) a는 pa 를 간접참조하여 바꿀 수 없음. -> 앞선 예제에서는 *pa = 10;으로 간접 참조로 바꿨는데 const를 사용하면 이게 안됨.

//     printf("변수 a 값 : %d\n",*pa);
//     pa = &b;
//     printf("변수 b 값 : %d\n", *pa);
//     pa = &a;
//     a = 20;
//     printf("변수 a 값 : %d\n", *pa);

// // 주소와 포인터의 차이 : 주소는 상수고, 포인터는 변수라서 포인터의 값은 바뀔 수 있다. 
// // ---> 주소는 한 번 설정되면 다시 실행하기 전까지는 안바뀜. but, 포인터는 a의 주소, b의 주소 ,..., 할당 해주고 싶을 때 마다 바뀔 수 있음. 
// // 두 개 이상의 포인터가 하나의 변수를 가리킬 수 있음.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 주소와 포인터의 크기
// int main(void)
// {
//     char ch;
//     int in;
//     double db;

//     char *pc = &ch;
//     int *pi = &in;
//     double *pd = &db;

//     printf("char형 변수의 주소 크기 : %d\n", sizeof(&ch));
//     printf("int형 변수의 주소 크기 : %d\n", sizeof(&in));
//     printf("double형 변수의 주소 크기 : %d\n", sizeof(&db));

//     printf("char* 포인터의 크기 : %d\n", sizeof(pc));
//     printf("int* 포인터의 크기 : %d\n", sizeof(pi));
//     printf("double* 포인터의 크기 : %d\n", sizeof(pd));

//     printf("char* 포인터가 가리키는 변수의 크기 : %d\n", sizeof(*pc));
//     printf("int* 포인터가 가리키는 변수의 크기 : %d\n", sizeof(*pi));
//     printf("double* 포인터가 가리키는 변수의 크기 : %d\n", sizeof(*pd));

//     return 0;
// }
    
// // 32비트에서는 [주소의 크기,포인터의 크기] 가 4바이트(강의노트에서는 4바이트로 나오는 이유), 64비트에서는 8바이트
// // 출력 결과 값 : 주소와 포인터의 크기는 8 바이트로 모두 같고, 변수의 크기는 1,4,8

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 예제1) 포인터를 이용한 변수 값 변경 
// // 문제 : 정수 변수 a 를 선언하고 초기 값 10 을 저장한 뒤 포인터 이용해 변수 a의 값을 20으로 변경해보기. (간접 참조 연산자 사용) 
//     int a = 10;
//     int *pa;

//     pa = &a;

//     printf("Before : %d\n",*pa);

//     *pa = 20;                 //선언할 때 const를 사용하면 불가능함.
//     printf("After : %d\n",*pa);

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 포인터의 대입 규칙
//     int a = 10;
//     int *p = &a;
//     double *pd;     //1)int*pd;
//     pd = p;     //2)pd = (double*)p;

//     printf("%lf\n",*pd);        //1)printf("%d\n",*pd);
//     //2)printf("%d\n",*(int*)pd);

//     // 10이 출력될 것 같지만 이상한 값이 나옴. bec, 가르키는 자료형에 맞게 포인터를 선언하지 않았기 때문임(double-int). 주석대로 바꾸면 10이 정상적으로 출력됨.
//     // 형 변환연산자(test4.c-참고)를 사용해 printf("%d\n",(int)*pd)로 바꿔도 안되는 이유?
//     // pd는 p안의 값 = a의 주소값, *pd 는 a의 값 = 10임. 이미 int인 10을 int로 바꾸라는건 의미가없음 
//     // -->> 의도한 10을 출력하기 위해서는, pd = (double*)p;로 같은 형태로 넣어주고, printf("%d\n",*(int*)pd) 형태로 바꿔야함.
//     // (int*)pd 는 왜 안돼는가 ? -> (int*)pd 는 double이었던 pd 의 형태를 int로 바꾸는 것, printf("%d\n",pd)와 값이 같음> 그냥 주소만 읽어옴
//     // *(int*)pd를 해야 int형태로 바꾼 pd의 주소가 바라보는 값을 출력함.
    
  
//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 포인터를 사용하는 이유

// void swap(int*pa, int*pb);
// int main(void)
// {
//     int a =10, b = 20;
//     swap(&a,&b);
//     printf("a:%d,b:%d\n",a,b);

//     return 0;
// }
// void swap(int*pa, int*pb)
// {
//     int temp;

//     temp = *pa;
//     *pa = *pb;
//     *pb = temp;
// }
// // main과 swap함수는 값을 공유하지 않음. 둘의 상호 작용을 도와주는 것이 포인터임. 주소는 변하지 않기 때문에
// 함수간의 데이터를 공유할 수 있게 해줌.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 예제2) 키보드로 실수 3개를 입력한 후 큰 숫자부터 작은숫자로 정렬한 뒤 출력하는 프로그램 작성

// void swap(double *pa, double *pd);
// void line_up(double *maxp, double *midp, double *minp);

// int main(void)
// {
//     double max, mid, min;

//     printf("실수값 3개 입력 : ");scanf("%lf%lf%lf",&max, &mid, &min);
//     line_up(&max, &mid, &min);
//     printf("정렬된 값 출력 : %.1lf, %.1lf, %.1lf\n", max, mid, min);
//     return 0;
// }
// void swap(double *pa, double*pb){
//     double temp;
//     temp = *pa;
//     *pa = *pb;
//     *pb = temp;
// }

// void line_up(double *maxp, double*midp, double*minp){
//     double temp = 0.0;
//     if(*midp > *maxp){
//         swap(midp,maxp);
//     }
//     if(*minp > *maxp){
//         swap(minp,maxp);
//     }
//     if(*minp > *midp){
//         swap(minp,midp);
//     }
// }

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 배열과 포인터
// // 한 배열명 안의 배열은 연속된 주소를 가진다 ary[500]; &a[0]=100 이라면, &a[50] = 151 인 것처럼
// int main(void)
// {
//     int ary[3];
//     int i;

//     *(ary + 0) = 10;
//     *(ary +1) = *(ary + 0) +10;
//     printf("ary의 주소: %u\n",ary);
//     printf("ary의 주소: %u\n",&ary[1]);
//     printf("ary의 주소: %u\n",ary+2);

//     printf("세 번째 배열 요소에 키보드 입력 : ");scanf("%d", ary +2);
    
//     for (i =0;i<3;i++){
//         printf("%5d",*(ary+i));
//     }
//     printf("\n");
//     return 0;
// }
// // ary는 ary[0]의 주소 (&ary[0])와 같다. ary + 2는 ary[2]의 주소 (&ary[2])와 같다. -> scanf 에서 &를 추가로 쓸 필요가 없음.
// // ary의 주소가 1칸당 4씩 차이남. int로 선언했기 때문. if double ary, 1칸당 8씩 차이남

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 배열명 역할을 하는 포인터
// int main(void){
//     int ary[3];
//     int *pa = ary;
//     int i;

//     *pa = 10;
//     *(pa +1) = 20;
//     pa[2] = pa[0] + pa[1]; // 대괄호를 써서 pa 를 배열명 처럼 사용함. ==ary[2] = ary[0] + ary [1]

//     for (i=0;i<3;i++){
//         printf("%5d",pa[i]);
//     }
//     printf("\n");
//     return 0;
// }

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 배열명과 포인터의 차이
//     int ary[3]
//     int *pa = ary;
//     sizeof(ary) -> 12바이트 (4*3)
//     sizeof(pa) -> 8바이트 (포인터 하나의 크기) ,32비트에서는 4바이트

//     ary = ary + 1 (X) //100번지에서 101번지를 참조하도록 바꿀 수는 있지만 -> 100번지를 101번지로 바꿀수는 없음.
//     ary ++ (X) // 배열명은 값을 바꿀 수 없음. 

//     pa = pa + 1 (O)
//     pa ++ (O) // 포인터는 값을 바꿀 수 있음. 포인터는 변수니까 어딜 가리키는지가 바뀌는 것임.
// int main(void)
// {
//     int ary[3] = {10,20,30};
//     int *pa = ary;
//     int i;

//     printf("배열의 값 : ");
//     for(i=0;i<3;i++){
//         printf("%5d",*pa);      //pa가 가리키는 배열 요소 출력 printf("%5d",*(pa++));로 바꿔도 10 20 30 이 출력됨.
//         pa++;                       // 다음 배열 요소를 가리키도록 pa 값 증가
//     }
//     printf("\n");
//     return 0;
// }

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 포인터의 뺼셈과 관계 연산
// int main(void)
// {
//     int ary[5] = {10,20,30,40,50};
//     int *pa = ary;
//     int *pb = pa +3 ;

//     printf("pa : %u\n", pa);
//     printf("pb : %u\n", pb);
//     pa ++;
//     printf("pb - pa : %u\n",pb - pa);
//     if (pa < pb)printf("%d\n",*pa);
//     else printf("%d\n",*pb);

//     return 0;
// }
// // 출력 : pa : 829674880, pb : 829674892, pb - pa : 2, 20 
// // 포인터에 배열명을 저장하면 배열명처럼 쓸 수 있다.
// // 배열명의 정수 덧셈은 가리키는 자료형의 크기를 곱해서 더한다 int ary[3]; ary가 100이라면 ary+1 = 104 : 1*4(int)
// // 포인터의 뺄셈 결과는 배열 요소간의 간격 차이를 의미한다. 몇칸 차이가나는지 (덧셈처럼 자료형이 곱해지지않음)

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 배열의 값을 출력하는 함수
// void print_ary(int*pa);
// int main(void)
// {
//     int ary[5] = {10,20,30,40,50};
//     print_ary(ary);
//     printf("\n");
//     return 0;
// }
// void print_ary(int*pa){
//     int i;
//     for(i=0;i<5;i++){
//         printf("%5d", pa[i]);
//     }
// }

// ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 배열 요소의 개수가 다른 배열도 출력하는 함수

// void print_ary(int *pa, int size);
// int main(void){
//     int N_1, N_2;
    

//     int ary1[5] = {10,20,30,40,50};
//     int ary2[7] = {10,20,30,40,50,60,70};

    // N_1 = sizeof(ary1)/sizeof(ary1[0]);                 
    // N_2 = sizeof(ary2)/sizeof(ary2[0]);
    
//     print_ary(ary1,N_1);
//     printf("\n");
//     print_ary(ary2,N_2);

//     printf("\n");
//     return 0;
// }
// void print_ary(int *pa,int size){
//     int i;
//     for (i =0 ; i < size ; i ++){
//         printf("%5d",pa[i]);
//     }
// }

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
//*********************다시 해보기 *********************//
// // 배열에 값을 입력하는 함수
// void input_ary(double *pa, int size);
// double find_max(double *pa, int size);
// int main (void){
//     double ary[5];
//     double max;
//     int size = sizeof(ary)/ sizeof(ary[0]);
//     input_ary(ary,size);
//     max = find_max(ary,size);
//     printf("배열의 최댓값 : %.1lf\n",max);
//     return 0;
// }
// void input_ary(double *pa, int size){
//     int i ;
//     printf(" %d개 실수 값 입력 : ", size);
//     for(i = 0; i <size ; i ++){
//         scanf("%lf",pa+i);
//     }
// }
// double find_max(double *pa, int size){
//     double max;
//     int i;
//     max = pa[0];
//     for(i = 0; i < size ; i++){
//         if(pa[i]> max) max = pa[i];
//     }
//     return max;
// }

// 배열을 입력/출력하는 함수에 필요한 것은 배열명임. 
// 배열의 크기가 달라도 입출력이 가능하려면 배열 요소의 개수를 알아함. sizeof 사용

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// 11.1 아스키코드 값과 문자 입출력 함수 부분은 한 번 읽어보기 강의노트 3장 
// // 아스키코드 
// int main(void) {
//     char small , cap = 'G';
//     if ((cap >= 'A')&& (cap <= 'Z')){
//         small = cap + ('a' -'A');       // 71 + 32 = 103 -> g
//     }
//     printf("대문자 : %c%c",cap, '\n');

//     printf("소문자 : %c\n", small);
//     return 0;
// }
// // A = 65 a = 97 -> 대소문자의 아스키코드값 차이 32. g(103)와 G(71)의 차이도 32로 같음.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 11.2 버퍼(Buffer)를 사용하는 입력 함수
// // 키보드에 버퍼가 없다면 하나를 입력할 때 마다 그 값을 CPU에 날리기 때문에 2가지 단어나 숫자를 입력하기 어려움
// // 이를 해결하기 위해 중간에 버퍼라는 메모리를 두어 엔터를 치기 직전까지 모든 값을 저장했다가 엔터를 받으면 버퍼에 저장된 값들을 한 번에 날림.

// // scanf함수가 문자를 입력하는 과정
// int main(void)
// {
//     char ch;
//     int i;

//     for (i=0;i<6;i++){
//         scanf("%c",&ch);
//         printf("%c",ch);        
//     }
    
//     printf("\n");
//     return 0;
// }

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 입력 문자의 아스키 코드 값을 출력하는 프로그램

// int main(void)
// {
//     int res;
//     char ch;

//     while(1){
//         res = scanf("%c",&ch);
//         if (res == -1) break;
//         printf("%d",ch);
//     }
//     return 0;
// }
// // A 입력 -> 6510 -> 65(A),10(\n)
// // cat -> 99(c),97(a),116(t),10(\n) 
//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // getchar 함수를 사용한 문자열 입력
// void my_gets(char*str,int size);
// int main(void)
// {
//     char str[7];
//     my_gets(str,sizeof(str));
//     printf("입력한 문자열 : %s\n",str);
//     return 0;
// }

// void my_gets(char*str,int size){
//     int ch;
//     int i =0;

//     ch = getchar();
//     while((ch !='\n') && (i < size-1)){
//         str[i] = ch;
//         i++;
//         ch = getchar();
//     }
//     str[i] = '\0';      // 입력한 문자열의 끝에 널 문자를 저장 -> 널 문자가 없다면, 어디까지 읽으라는 지시가 없을 때 메모리를 전부 뒤져서 널 문자가 나올 때 까지 읽음.

// }

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// 입력 버퍼 지우기 - 버퍼의 내용을 지워야 하는 경우

// int main(void)
// {
//     int num, grade ;

//     printf("학번 입력 : ");
//     scanf("%d",&num);
//     getchar();          // 버퍼에 남아있는 개행문자(\n) 제거
//     printf("학점 입력 : ");
//     grade = getchar();
//     printf(" 학번 : %d, 학점 : %c\n",num,grade);
//     return 0 ;
// }
// 학번 입력 : 315
// 학점 입력 :  학번 : 315, 학점 : 
// getchar()이 없다면 위처럼 학번 315 입력 이후 학점을 입력할 수 없고 학점을 출력할 곳에서 줄이바뀜 (버퍼에 \n이 남아있기 때문에 학점을 입력할 수 없음 버퍼에 있는 것을 먼저 출력하기 때문임.)

// getchar()의 동작 getchar()은 stdio.h 에 있는 기본 함수
// 버퍼에 읽을 문자가 있을 때: 버퍼의 가장 앞에 있는 문자 1개를 즉시 반환하고, 그 문자를 버퍼에서 삭제함.
// 버퍼가 비어 있을 때: 사용자가 키보드로 무언가를 입력하고 Enter 키를 누를 때까지 프로그램이 잠시 멈추고 기다립니다. 입력이 들어오면 그중 첫 번째 문자를 반환.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 12.1 문자열과 포인터

// // 기존에 문자열을 넣기 위해서는 %s 등을 이용해서 값을 받았거나, 배열을 이용해 ary1[10]= {'a','b',',,,,} 등으로 받아왔음. (변수에 값을 넣는 행위)
// // 10을 선언하지 않고도 쓸 수 있듯이, C언어에서는 큰따옴표(" ")로 묶인 모든 것은 그 자체로 '값'으로 취급됨.
// // "읽기 전용" 메모리에 저장: 컴파일러가 "apple"이라는 문자열(a, p, p, l, e, \0)을 프로그램의 '읽기 전용 데이터'라는 특별한 구역에 자동으로 저장합니다.
// // 주소로 변환: 그리고 코드에서 "apple"이라고 쓴 부분을, 컴파일러가 방금 저장한 그곳의 시작 주소 값(포인터)으로 바꿔치기합니다.


// // 문자열 상수가 주소란 증거

// int main(void)
// {
//     printf("apple이 저장된 시작 주소 값 : %p\n","apple");
//     printf("두 번째 문자의 주소 값 : %p\n","apple"+1);
//     printf("첫 번째 문자 : %c\n",*"apple");
//     printf("두 번째 문자 : %c\n",*("apple"+1));
//     printf("배열로 표현한 세 번째 문자 : %c\n","apple"[2]);

//     return 0;
// }
// // 출력 결과 :  apple이 저장된 시작 주소 값 : 0x611bbefc5008 , 두 번째 문자의 주소 값 : 0x611bbefc5009, 첫 번째 문자 : a , 두 번째 문자 : p , 배열로 표현한 세 번째 문자  : p

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // scanf함수를 사용한 문자열 입력
// int main(void)
// {
//     char str[80];
//     printf("문자열 입력 : ");
//     scanf("%s",str);
//     printf("첫 번쨰 단어 : %s\n",str);
//     scanf("%s",str);
//     printf("버퍼에 남아 있는 두 번째 단어 : %s\n",str);
//     return 0;
// }
// 입력 : apple jam - > apple\0jam 첫 출력에서 \0(널문자) 이전까지 출력하고 이후 scanf를 했지만 입력 칸은 안나오고 버퍼에 남아있는 jam이 출력됨.
// 최종 상태: ['j'|'a'|'m'|'\0'|'e'|'\0'| ? | ... ]  j, a, m, \0가 a, p, p, l을 덮어썼지만, 기존 인덱스 4의 'e'와 인덱스 5의 '\0'은 덮어쓸 데이터가 없어서 그대로 남아있게 됩니다.
// printf는 인덱스 3에서 멈췄기 때문에, 그 뒤에 'e'가 남아있든 'z'가 남아있든 전혀 신경 쓰지 않습니다.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// int main(void)
// {
//     char str[80];

//     printf("공백이 포함된 문자열 입력 :");
//     gets(str);
//     printf("입력한 문자열은 %s 입니다.\n",str);

//     return 0;
// }
// 공백이 포함된 문자열 입력 :        , 입력한 문자열은        입니다.
// scanf 는 문자가 들어오기 시작하면 그게 값인 줄 알고 읽음. (스페이스바나 엔터를 많이 눌러도 문자가 나오기 전까지는 인식 안함.)
// gets 는 공백도 포함하여 모든 값을 받음.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// fgets 함수를 사용한 문자열 입력
#include <string.h> //strlen 함수 (문자열 길이를 재는 함수)를 쓰기 위해서는 #include <string.h> 헤더 파일을 포함해야 함.

int main(void)
{
    char str[80];
    printf("공백이 포함된 문자열 입력 :");  
    fgets(str, sizeof(str), stdin);     // (str 배열에, str의 크기(80)만큼, 표준 입력(stdin)으로부터 받음)    
    str[strlen(str)-1] = '\0'; // str[strlen(str)-1] = '\0' -> a p p l e () j a m \n \0 에서 개행 문자 (\n)를 널문자 (\0)로 바꿈. ->> get처럼 출력 됨.
    printf("입력한 문자열은 %s 입니다.\n", str); //배열명은 주소다.

    return 0;
}
// // gets 와 fgets 의 차이 : get는 apple jam을 입력한 후 엔터를 치면 apple jam\0을 저장하지만, fgets는 apple jam\n\0을 저장함. -> \n까지 포함하여 저장
// // 출력 : 공백이 포함된 문자열 입력 : apple jam
// //      입력한 문자열은 apple jam       -> (\n)이 포함되어 다음 문자인 "입니다."를 다음 줄로 내려버림
// //      입니다.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 표준 입력 함수의 버퍼 공유 문제 (개행 문자로 인해 gets 함수가 입력을 못하는 경우)

// int main(void)
// {
//     int age[20];
//     char name[20];

//     printf("나이 입력 : ");
//     scanf("%d",&age);
//     // getchar();
//     printf("이름 입력 : ");
//     gets(name);
//     printf("나이 : %d, 이름 : %s\n",age,name);
//     return 0;

// }
// // get는 버퍼에 남아있던 엔터(\n)가 name에 적용되어 바로 출력
// // 나이 입력 : 17
// // 이름 입력 : 나이 : 17, 이름 : 
// // 버퍼에 읽을 문자(\n)가 있으므로, getchar()를 사용하여 버퍼의 가장 앞에 있는 문자 1개를 즉시 반환하고, 그 문자를 버퍼에서 삭제하여 name을 받을 수 있도록 함.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 문자열을 출력하는 puts,fpust함수
// int main(void)
// {
//     char str[80] = "apple juice";
//     char *ps = "banana";

//     puts (str);
//     fputs (ps,stdout);
//     puts("milk");

//     return 0;
// }

// // puts(str): str 배열에 이미 저장되어 있는 문자열을 모니터에 출력합니다. 그리고 자동으로 \n(줄바꿈)을 출력에 덧붙입니다.
// // fputs(str, ...): str 배열에 이미 저장되어 있는 문자열을 모니터에 출력합니다. (줄바꿈 덧붙이지 않음)
// // 결론: puts는 "출력하고 + 자동으로 줄바꿈(Enter)을 덧붙여주는 printf"임.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

//strcpy 함수의사용법 

// #include<string.h>

// int main(void)
// {
//     char str1[80] = "strawberry";
//     char str2[80] = "apple";
//     char *ps1 = "banana";
//     char *ps2 = str2;

//     printf("최초 문자열 : %s\n",str1);
//     strcpy(str1,str2);      //strcpy(복사 받을 곳, 복사 할 곳)
//     printf("바뀐 문자열 : %s\n",str1);
//     strcpy(str1,ps1);               
//     printf("바뀐 문자열 : %s\n",str1);
//     strcpy(str1,ps2);
//     printf("바뀐 문자열 : %s\n",str1);
//     strcpy(str1,"banana");
//     printf("바뀐 문자열 : %s\n",str1);

//     return 0;
// }

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 원하는 개수의 문자만을 복사하는 strncpy 함수
// #include<string.h>
// int main(void)
// {
//     char str[20] = "mango tree";
//     strncpy (str, "apple-pie",5);            // strncpy(복사 받을 배열 명, 복사할 문자열, 복사할 문자 수)
//     // strncpy (str+5,"apple-pie",5);       // 만약 apple tree 가 아니라 mangoapple 를 출력하려고 한다면, str+5를 넣으면 거기서부터 바뀜 
    
//     printf("%s\n",str);
//     return 0;
// }
// // 복사할 문자 수가 5이므로 apple-pie의 apple까지 받음
// //str[5]는 안됨 (str + 5: C언어의 '포인터 연산'입니다. "시작 주소로부터 5칸 뒤의 주소"를 의미함. str[5]: "mango tree" 배열의 5번 인덱스에 저장된 값임.
// // strncpy는 첫 번째 인자로 주소(char *)를 기대했는데, char 타입의 값(' ')이 전달되었기 때문에 오류발생.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// 문자열을 붙이는 strcat, strncat 함수
// #include<string.h>
// int main(void)
// {
//     char str[80] = "straw";
//     // str[1] = '\0';
//     strcat(str, "berry");
//     printf("%s\n",str);
//     strncat(str,"piece",3);
//     printf("%s\n",str);
//     return 0;

// }
// // strcat을 그냥 붙이면 맨 뒤 \0(널 문자) 뒤에서 부터 붙이게 됨.
// // 원하는 곳에 문자를 붙이기 위해서는 원하는 곳의 배열을 널문자로 바꿔줘야 함 (str[4] = '\0')
// // // str[10]으로 선언하면 strawberry에서 10자리를 다 차지함. 이 후 strcat을 사용하면 이미 할당된 메모리 공간 밖으로 추가할 문자들이 빠져나감 -> 다른 메모리 공간을 침범해 큰 문제가 생길 수 있음.
// // // 따라서 strcat을 사용할 때는 충분한 공간을 선언하는 것이 중요함.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 문자열 길이를 계산하는 strlen 함수
// int main(void)
// {
//     char str1[80],str2[80];
//     char *resp;
//     printf("2개의 과일 이름 입력 : ");
//     scanf("%s%s",str1,str2);
//     if (strlen(str1)> strlen(str2)){
//         resp = str1;
//     }else resp = str2;
//     printf("이름이 긴 과일은 : %s\n",resp);
//     return 0;
// }

// //sizeof 문자열의 내용과 관계없이, 선언 시 할당된 메모리 공간의 총 크기를 봄(sizeof(str1)의 값은 항상 80 앞에서 선언했기 때문)
// //strlen은 배열에 포함된 문자열의 길이를 보는 것.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 문자열을 비교하는 strcmp, strncmp 함수
// // 사전에 나중에 나오는 과일 이름을 비교 -> 아스키코드값으로 비교함
// // pear - peach 비교 -> pear (pea 까지는 같고 r(114)과 c(99) 비교 c가 더 작음 -> \0(0)과 h(108)비교  \0이 더 작음 
// //--> 출력 :  pear 마지막글자를 비교하지 않아도 앞에서 c 가 더 작으므로 peach가 사전에 더 먼저 나옴)

// int main(void)
// {
//     char str1[80] = "peach";
//     char str2[80] = "pear";
//     printf("사전에 나중에 나오는 과일 이름 : ");
//     if (strcmp(str1,str2) > 0){         // str1이 str2보다 사전에 나중에 나오면(아스키 코드값이 크면) 1반환. /  str1이 str2보다 사전에 먼저 나오면 -1 반환. / 같으면 0반환
//         printf("%s\n",str1);
//     }else printf("%s\n",str2);

//     return 0;
// }


// strcmp (앞,뒤) : 앞이 크면 1 앞이 작으면 -1 같으면 0 반환
//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
//     return 0 ;
// }