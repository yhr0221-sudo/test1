#include<stdio.h>
// 교재 혼자공부하는 C언어 (한빛미디어 - 서현우지음)
// 13. 변수의 영역과 데이터 공유

// 지역변수 개념 : 두 함수에서 같은 이름의 지역변수를 사용해도 값은 본 함수(main)에 영향을 미치지 않음. -> 포인터를 사용해 주소값을 변경해주는 작업을 하면 본 함수에도 영향을 끼칠 수 있음.
// 지역 변수는 선언된 블럭 안에서만 사용 가능 -> 디버깅에 유리함. , 선언된 블록이 끝나면 저장공간이 메모리에서 사라진다 -> 메모리를 효율적으로 사용가능.
// 지역변수 <-> 전역변수 (반대개념)
//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// 블록 안에서 사용하는 지역변수(지역 변수의 사용 범위는 블록{}으로 제한됨.) 
// temp가  {} 내부에서만 쓰임 -> 메모리 효율적 사용 목적. 블럭안의 변수가 무수히 많다면 유의미한 활용이 됨.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 전역 변수 
// void assign10(void);
// void assign20(void);

// int a;      // 전역 변수 선언 

// int main(void)
// {
//     printf("함수 호출 전 a 값 : %d\n",a);
//     assign10();
//     assign20();
//     printf("함수 호출 후 a 값 : %d\n",a);
//     return 0;
// }
// void assign10(void){
//     a = 10;         // 전역변수에 접근하여 값(10)을 대입. 
// }
// void assign20(void){
//     int a;          // 새로운 지역변수 a(assign20) 를 만들어 그 변수에 20을 대입 -> 본 함수에는 영향이 없음.
//     a = 20;
// }

// // 출력 - 함수 호출 전 a 값 : 0 , 함수 호출 후 a 값 : 10
// // *****전역변수는 특별한 값을 지정하지 않으면 자동으로 0으로 초기화함*****
// // 전역 변수 : 이름이 바뀌면 사용함수의 모든 이름을 찾아 바꿔야한다. / 값이 이상하면 접근 가능한 모든 함수를 살펴야 함.(디버깅이 힘듬) / 같은 이름의 지역 변수에 의해 사용범위가 제한된다. (assign20에서 a는 지역변수로, 이름이 같은 전역번수는 사용이 어려움)
// 지역 변수와 전역변수의 사용 범위가 겹치면 지역 변수를 먼저 사용한다. 

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 정적 지역 변수
// void auto_func(void);
// void static_func(void);

// int main(void){
//     int i;
//     printf("일반 지역변수(auto)를 사용한 함수 ...\n");
//     for (i =0 ; i<3;i++)
//     {
//         auto_func();
//     }
//     printf("정적 지역 변수(static)를 사용한 함수 ...\n");
//     for(i=0;i<3;i++)
//     {
//         static_func();
//     }
//     return 0;
// }
// void auto_func(void){
//     auto int a = 0;
//     a++;
//     printf("%d\n",a);
// }
// void static_func(void){
//     static int a;
//     a++;
//     printf("%d\n",a);
// }

// // 출력 - 일반 지역변수(auto)를 사용한 함수 ... 1 1 1 // 정적 지역 변수(static)를 사용한 함수 ... 1 2 3
// //일반 지역 변수 (auto): 함수가 호출될 때마다 새로 생성. (매번 a = 0으로 초기화).함수가 끝나면 즉시 사라져 메모리에서 제거되기 때문에 auto_func는 매번 1만 출력.
// //정적 지역 변수 (static): 프로그램이 시작될 때 단 한 번만 생성.(단 한 번 a = 0으로 초기화).함수가 끝나도 사라지지 않고 값을 계속 기억하므로 static_func는 1, 2, 3으로 값이 누적됩니다.
// static 은 전역변수로도 사용 가능. 단, 변수가 선언된 그 .c 파일 안에서만 접근할 수 있음. 다른 파일에서는 extern으로도 이 변수에 접근할 수 없음. (변수를 해당 파일에 "private"하게 숨김)


//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 레지스터 변수
// int main(void)
// {
//     register double i;
//     auto double sum = 0;
//     for(i=1;i<=10000000;i++){
//         sum+=i;        
//     }
//     printf("%lf\n",sum);
//     return 0;
// }

// // 일반 메모리보다 읽고 쓰기가 빠른 레지스터에 집어넣어 연산을 처리함.
// 전역 변수는 레지스터 변수로 선언할 수 없다. / 레지스터 변수는 주소를 구할 수 없다. / 레지스터의 사용 여부는 컴파일러가 결정한다 .

// RAM - stack(지역변수, 매개변수 - {}가 끝나면 사라진다) / heap(동적 메모리 - 개발자가 컨트롤하는 영역, 썼다가 지웠다를 직접 해야함) / data (전역변수, static변수 - 프로그램 실행부터 종료까지)
// stack 과 data는 시스템이 관리. heap는 개발자가 관리함. ->> 나중에 추가 설명

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 값을 복사해서 전달하는 방법

// void add_ten(int a);
// int main (void){
//     int a = 10;
//     add_ten(a);
//     printf("a(main): %d\n",a);
//     return 0;
// }
// void add_ten(int a)
// {
//     a = a + 10;
//     printf("a(add_ten) : %d\n",a);
// }
// // 지역함수이므로 본 함수에서 10이 증가하지는 않음.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 주소를 전달하는 방법 (포인터를 사용해서 변수에 10을 더하는 경우)
// void add_ten(int *pa);
// int main (void){
//     int a = 10;
//     add_ten(&a);
//     printf("a(main): %d\n",a);
//     return 0;
// }
// void add_ten(int *pa)
// {
//     *pa = *pa + 10;
// }
// // 주소를 받아서 하므로 본 함수에도 영향을 미침.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// 주소를 반환하는 함수 (주소를 반환하여 두 정수의 합을 계산)

// int *sum (int a, int b);
// int main(void)
// {
//     int *resp;
//     resp = sum (10,20);         //resp = &res ->> res 의 주소. 즉, a+b의 값이 담긴 주소를  받음 -> printf 했을 때 resp가 바라보는 주소의 값은 a+b = 30
//     printf("두 정수의 합 : %d\n",*resp);
//     return 0;
// }
// int *sum(int a, int b){
//     static int res;
//     res = a + b;
//     return &res;
// }

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// 14 다차원 배열 

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// 2차원 배열 선언과 요소 사용

// int main(void)
// {
//     int score[3][4];
//     int total;
//     double avg;
//     int i, j;

//     for (i=0;i<3;i++){
//         printf("4과목의 점수 입력 : ");
//         for (j = 0; j < 4; j ++){
//             scanf("%d", &score[i][j]);
//         }
//     }
// }
// (0,1), (0,2), (0,3), (0,4), (1.1), ... ,(3,3) , (3,4) 순서로 쭉 채워짐.

// /// 2차원 배열의 초기화 방법
//     int mun [3][4] = {
//         {1,2,3,4},      // 0행
//         {5,6,7,8},      // 1행
//         {9,10,11,12}    // 2행
//     };

// 일부 초기값 생략 가능 - int num[3][4] = {{1},{5,6},{9,10,11}};
// 행의 수 생략 가능 int num[][4] = {{1},{2,3},{4,5,6}}; ----- 각 행을 {}로 선언 했기 때문에 행의 수를 생략 할 수 있음.
// 1차원 배열의 초기화 방식으로 초기화 가능 - int num[3][4] = {1,2,3,4,5,6,7,8,9.10,11,12};
// 초기화시 남는 저장 공간은 0으로 자동 초기화 int num[3][4] =  {1,2,3,4,5,6}; 
// 행의 수가 생략되고 초깃값이 적은 경우 - int num [][4] = {1,2,3,4,5,6}; ->  {{1,2,3,4},{5,6,0,0}}의 형태
// 열은 생략하지 않음.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 2차원 char 배열 초기화
// char animal1[5][10] = {{'d','o','g','\0'}, {'t','i','g','e','r','\0'},...}; 처럼 끝에 널 문자를 추가해 줘야함.
// char animal1[][10] = {"dog","tiger", ...};

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 3차원 배열 
// int score [2][3][4] -> [2] : 면 ,[3] : 행, [4] : 열 - (2x3x4)형태의 직육면체를 생각하면 됨.
// int score [2][3][4] = {
//     {{0,0,0,0}, {0,0,0,0}, {0,0,0,0}},       // 0면
//     {{0,0,0,0}, {0,0,0,0}, {0,0,0,0}}        // 1면
// } 
// int main(void){
//     int score [2][3][4] = {
//         {{72,80,95,60}, {68,98,83.90},{75,72,84,90}},
//         {{66,85,90,88},{95,92,88,95},{43,72,56,75}}
//     };
//     int i,j,k;
//     for (i = 0; i<2; i++)
//     {
//         printf("%d 반 점수 ...\n", i+1);
//         for(j = 0 ; j < 3; j ++){
//             for(k = 0 ; k < 4 ; k ++)
//             {
//                 printf("%5d",score[i][j][k]);
//             }
//             printf("\n");
//         }
//         printf("\n");
//     }
//     return 0;
// }

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// 포인터 배열 선언과 사용
// 
// int main(void){
//     char *pary[5];  // char : 배열 요소의 자료형 , pary : 배열명, [5] : 배열 요소의 개수 / 포인터 배열 : 각 요소에 주소를 가지는 배열
//     int i ;
// 
//     pary[0] = "dog";        // "dog"의 값을 가진 주소값을 pary[0]에 넣기
//     pary[1] = "elephant";
//     pary[2] = "horse";
//     pary[3] = "tiger";
//     pary[4] = "lion";
// 
//     for (i=0;i<5;i++){
//         printf("%s\n",pary[i]);
//         printf("%p\n",pary+i);
//     }
//     return 0;
// }

// *pary[5] = 40바이트 (주소값을 가지므로) / animal[5][20] = 100바이트 (1바이트짜리 문자열 100개를 담을 공간이므로)
// //ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 2차원 배열처럼 활용하는 포인터 배열 
// int main(void)
// {
//     int ary1[4] = {1,2,3,4};
//     int ary2[4] = {11,12,13,14};
//     int ary3[4] = {21,22,23,24};
//     int *pary[3] = {ary1, ary2, ary3};
//     int i,j;

//     for (i=0;i<3;i++){
//         for(j=0;j<4;j++){
//             printf("%5d", pary[i][j]);
//         }
//         printf("\n");
//     }
//   return 0;
// }
// //pary[i][j]와 pary[i] + j는 다름.
// pary[i][j] (값): j번째 요소 (예: 13)
// pary[i] + j (주소): j번째 요소의 주소 (예: 13이 저장된 메모리 번지)
// 만약 pary[i] + j를 꼭 사용하고 싶다면, printf 문을 다음과 같이 * (역참조 연산자)를 붙여서 수정해야 합니다.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


// 예제1) 가로세로의 합 구하기
// 5행6열 2차원 배열을 선언하고4행5열 부분은 1부터 20까지 초기화 합니다. 초기화 된 배열에서 마지막 열의 요소에는 각 행의 합을 저장하고 마지막 행의 요소에는 각 열의 합을 저장한 후 전체 배열의 값을 출력하세요.
// int main(void)
// {
//     int ary[5][6] = {{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15},{16,17,18,19,20}};
//     int i,j;
                                        //     // [4][0] -> [0][0]+[1][0]+ ..
                                        //     // [0][5] -> [0][0]+[0][1]+ ...
                                        //     // [4][5] -> [4][0]+[4][1]+...+[4][4] + [0][5]+[1][5]+ ...+[3][5]
// for (i = 0; i < 4; i++) // 행 (0~3)
//     {
//         for (j = 0; j < 5; j++) // 열 (0~4)
//         { 
//             ary[i][5] += ary[i][j];
//             ary[4][j] += ary[i][j];
//             ary[4][5] += ary[i][j];
//         }
//     }
//     for (i = 0; i < 5; i++) // 전체 행 (0~4)
//     {
//         for (j = 0; j < 6; j++) // 전체 열 (0~5)
//         {
//             printf("%5d", ary[i][j]); 
//         }
//         printf("\n"); 
//     }
//     return 0;

// // }

// /// 포인터 활용해서 풀어보기

// int main(void){
//     int ary1[6] = {1,2,3,4,5};
//     int ary2[6] = {6,7,8,9,10};
//     int ary3[6] = {11,12,13,14,15};
//     int ary4[6] = {16,17,18,19,20};
//     int ary5[6] = {};
//     int *pary[5] = {ary1, ary2, ary3, ary4, ary5};
//     int i,j;

// for (i = 0; i < 4; i++) // 행 (0~3)
//     {
//         for (j = 0; j < 5; j++) // 열 (0~4)
//         {
//             pary[i][5] += pary[i][j];
//             pary[4][j] += pary[i][j];
//             pary[4][5] += pary[i][j];
//         }
//     }
//     for (i=0;i<5;i++){
//         for(j=0;j<6;j++){

//                 printf("%5d", pary[i][j]);
//         }s
//         printf("\n");
//     }
//   return 0;
// }


// // printf("%2d번째 -> 잔량  : %5.1f%% | 경고 상태 : %s\n", i+1, battery_log[i],(alert ==1)? "ON" : "OFF");
// /// 이중으로 검증해보기 행의합 , 열의합 == 마지막행렬의 값 -> 출력하기 | 출력하지 않기

// // sum_row = pary[i][5] 각 행의 합을 더한 값 + sum_column = pary[4][j] 각 열의 합을 더한 값
// // verify = sum_row + sum_column 이 같다면 0, 다르다면 1 
// // (verify == 0) ? 행렬 출력 : 오류 출력

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 15 응용 포인터

// // 이중 포인터 개념 

// int main(void)
// {
//     int a =10;
//     int *pi;
//     int **ppi;          // 이중 포인터

//     pi = &a;
//     ppi = &pi;
//     printf("ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ\n");
//     printf("    변수        변숫값       &연산               *연산           **연산\n");
//     printf("ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ\n");
//     printf("    a       %10d         %10u\n", a ,&a);
//     printf("    pi      %10u         %10u         %10d\n",pi,&pi,*pi);
//     printf("    ppi     %10u         %10u         %10u%10u\n", ppi,&ppi,*ppi,**ppi);
//     printf("ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ\n");

//     return 0;

// }

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// 이중 포인터의 형태 
// 포인터가 가리키는 자료형과 포인터 자체의 형태는 다르다 
// (int*) 형 포인터는 (int) 형을 가리키고, (double**)형 이중포인터는 (double*)형 포인터를 가리킨다.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 이중 포인터 활용

// void swap_ptr(char **ppa, char **ppb);
// int main(void)
// {
//     char *pa = "success";
//     char *pb = "failure";

//     printf("pa -> %s ,pb -> %s\n", pa,pb);
//     // %s는 문자열을 출력하라는 의미. C언어에서 문자열은 문자열의 시작 주소(메모리 주소)를 통해 다루어짐. 
//     // printf 함수는 %s를 만나면 함께 전달된 인자 값을 '문자열이 시작되는 주소'로 해석하고, 그 주소부터 널 문자(\0)를 만날 때까지 모든 문자를 출력.
//     // %c (단일 문자): 문자 값 (char)을 필요로 합니다. *pa를 사용합니다.
//     // 만약, printf("pa의 첫 글자 -> %c , pb의 첫 글자 -> %c\n", *pa, *pb); 
//     // 출력: pa의 첫 글자 -> s , pb의 첫 글자 -> f  
//     swap_ptr(&pa,&pb);
//     printf("pa -> %s ,pb -> %s\n", pa,pb);

//     return 0;
// }

// void swap_ptr(char**ppa, char **ppb){
//     char *pt;

//     pt = *ppa;
//     *ppa = *ppb;
//     *ppb = pt;
// }

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 이중 포인터 활용 2 : 포인터 배열을 매개변수로 받는 함수

// void print_str(char **pps,int cnt);
// int main(void)
// {
//     char *ptr_ary[] = {"eagle","tiger", "lion","squirrel"};
//     int count;

//     count = sizeof(ptr_ary) / sizeof(ptr_ary[0]);       // 배열의 개수를 확인할 수 있음 (count)
//     print_str(ptr_ary, count);
//     return 0;
// }

// void print_str(char **pps, int cnt)
// {
//     int i ;
//     for (i=0;i<cnt;i++){
//         printf("%s\n",pps[i]);
//     }
// }

// // ptr_ary 는 포인터배열 -> 각 배열에 주소를 담고있음. char **pps 는 주소를 받아야함 
// // -> void print_str(char **pps, int cnt)에서  char **pps에 해당하는 ptr_ary를 변수로 보내줌-> 포인터 배열을 매개변수로 받음
 
//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 배열 요소의 주소와 배열의 주소

// int main(void)
// {
//     int ary[5];

//     printf(" ary의 값 : %u\t", ary);
//     printf(" ary의 주소 : %u\n", &ary);     //&ary = ary = &ary[0] 값은 같지만 의미하는 바는 조금 다름 / &ary (배열 전체의 주소: 정수 5개짜리 '배열 전체') <-> ary (배열 이름 : 정수 하나)
//     printf(" ary+1 : %u\t", ary +1);
//     printf(" &ary +1 : %u\n", &ary + 1);    //&ary + 1(배열 전체가 넘어감 5*4 =20) != ary + 1= &ary[1]
//     return 0;
// }
// // %c: 문자/ %s: 문자열/ %d: 정수/ %lf: 실수/ %p: 16진수 주소/ %u: 10진수 주소
// // %lf는 scanf에서는 double을 받을 때 쓰지만, printf에서는 %f와 %lf 모두 double을 출력하며 차이 없다.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


// **************************다시보기********************************

// // 2차원 배열과 배열 포인터 (포인터 배열과 다름)

// int main(void)
// {
//     int ary[3][4] = {{1,2,3,4,},{5,6,7,8},{9,10,11,12}};
//     int (*pa)[4];       //int형 변수 4개의 배열을 가리키는 배열 포인터 (4개씩 짤라서 본다는 느낌)
//     int i,j;

//     pa = ary;
//     for (i=0;i<3;i++){
//         for(j=0;j<4;j++){
//             printf("%5d", pa[i][j]);
//         }
//         printf("\n");
//     }
//     return 0;

// }
// // 2차원 배열의 요소를 참조하는 원리(int ary[3][4] 라면)

// // ary + 1 -> 첫주소값(100이라가정) + (1*sizeof(ary[0])) -> 100 + (1*16) -> 116
// // *(ary+1) -> ary[1]
// // *(ary+1)+2 -> *(ary +1) + (2 *sizeof(ary[1][0])) -> 116 + (2*4) -> 124
// // *(*(ary+1)+2) -> ary[1][2] 

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 예제 2) 함수가 주소를 리턴하는 코드

// int *func(int a, int *x);

// int main(void){
//     int i ;
//     int x =10;
//     int *p;
//     int a[100];
//     for(i=0;i<100;i++){
//         a[i] = i*10;            // a는 0부터 990까지(10의 배수로) 담긴 배열
//     }

//     p = func(x,a);
//     printf("sum = %d\n", x + a[0] + a [1] + p[0] + p[1]);
//     return 0;
// }
// int *func(int a, int *x){
//     a = a + 10; --->헷갈리라고 넣어둔 쓰레기 줄
//     x = x +1;
//     *x = *x *2;
//     return x;
// }

// ?? p[0]까지는 이해 됐는데, p[1]이 왜 a[2]인가 ?
// p + 1: p가 가리키는 대상(int)의 크기만큼 1칸 뒤로 이동한 주소. 정확히 a[2]의 주소와 같습니다.*(p + 1): a[2]의 주소에 있는 값을 가져옵니다.


//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 함수 포인터 개념 (함수 포인터를 사용한 함수 호출)
// int sum (int, int);
// int main(void){
//     int (*fp)(int,int);
//     int res;
//     fp = sum;
//     res = fp(10,20);         /// 원래는 *fp(10,20) 처럼 써야함 근데 둘 다 됨.
//     printf("result : %d\n",res);
//     return 0;
// }
// int sum (int a, int b)
// {
//     return(a+b);
// }

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 함수 포인터의 활용

// void func(int(*fp)(int,int));
// int sum(int a,int b);
// int mul(int a, int b);
// int max(int a, int b);

// int main (void){

//     int sel;

//     printf("01 두 정수의 합 \n");
//     printf("02 두 정수의 곱 \n");
//     printf("03 두 정수 중에서 큰 값 계산 \n");
//     printf("원하는 연산을 선택하세요 : \n");
//     scanf("%d", &sel);
//     switch(sel) 
//     {
//         case 1: func(sum); break;
//         case 2: func(mul); break;
//         case 3: func(max); break;
//     }
//     return 0;

// }
// void func(int(*fp)(int,int)){
//     int a, b;
//     int res;
    
//     printf("두 정수의 값을 입력하세요 : \n");
//     scanf("%d %d",&a, &b);
//     res = fp(a,b);
//     printf("결과값은 : %d\n", res);

// }
// int sum (int a, int b)
// {
//     return(a+b);
// }
// int mul (int a, int b)
// {
//     return(a*b);
// }
// int max (int a, int b)
// {
//     if (a>b) return a;
//     else return b;
// }

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // void 포인터
// int main(void)
// {
//     int a = 10;
//     double b = 3.5;
//     void *vp;

//     vp = &a;
//     printf("a : %d\n",*(int*)vp);        //void로 선언했기 때문에 (int*)로 형 변환이 필요

//     vp = &b;
//     printf("b : %.1lf\n", *(double*)vp); //void로 선언했기 때문에 (double*)로 형 변환이 필요
//     return 0;

// }
// // 기존에는 선언할 때 어떤 데이터를 가리킬 지 (int, double ..)처럼 선언해줬음. void는 어떤 것을 가리킬지 모를 때, 여러가지 자료형을 가리키고 싶을 때 사용한다.

// // 정리 15.2
// // 함수명의 의미부터 보자면 함수명은 함수 정의가 있는 메모리의 시작주소이다. (배열과 같음)
// // 함수 포인터에 함수명을 대입하면 함수처럼 호출할 수 있다. (배열과 같음)
// // void포인터는 간접 참조 연산과 주소에 대한 정수 연산이 불가능함. -> 10을 20으로 바꾸라는 등 (X) 출력만 가능함

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ