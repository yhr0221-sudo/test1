#include <stdio.h>

int main(void)
{
    //scanf 함수를 사용한 키보드 입력 (python 에서 input역할)

    // int a ;
    // scanf("%d",&a);
    // printf("입력값 : %d\n", a);
//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
    // char grade;
    // char name[20];    
    // printf("학점 입력 :");
    // scanf("%c", &grade);
    // printf("이름 입력 :" );
    // scanf("%s", name);  // 배열 명에는 &를 사용하지 않는다.
    // printf("%s의 학점은 %c 입니다 .\n", name, grade);

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
// 증감 연산자 (피연산자의 값을 1증가시키거나 감소시킨다.)

    // int a = 10 , b = 10;
    // ++a;        //a++ ;    앞에서 하면 전위연산 뒤에서 하면 후위연산
    // --b;
    // printf("a : %d\n", a);
    // printf("b : %d\n", b);

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
    // int a = 10 , b = 10;
    // printf("a : %d\n", a++);  //10을 먼저 출력하고, 그 후에 1을 더함 (후위연산)
    // printf("b : %d\n", b--);
    // printf("a :%d\n",a); //11이 출력된 모습을 볼 수 있음
    // printf("a :%d\n",b);

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
    // int a = 5, b = 5 ;
    // int pre, post;

    // pre = (++a) * 3 ;
    // post = (b++) * 3 ;
    // printf("초기값 a = %d , b = %d\n", a,b);
    // printf("전위형 : (++a)*3 = %d, 후위형:(b++)*3 = %d\n", pre,post);
    // printf("%d\n", a); // printf문에서는 그냥 출력만 도와주는 것, 위의 printf에서 (++a)가 있어도 연산은 이뤄지지 않음

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
 
// 관계 연산자 (>, < , >=, <=, ==, !=) 
// 결과는 boolean으로 출력 0-> 거짓, 1-> 참

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// 논리 연산자 (&& (and), ||(or), !(not))
// 결과는 boolean으로 출력 0-> 거짓, 1-> 참
    // int a = 30;
    // int res;
    // res = (a<10) || (a>20);
    // printf("a<10 || a >20 : %d\n",res); 

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// 연산의 결과값을 처리하는 방법
// 연산의 결과는 저장하거나 바로 사용하지 않으면 사라짐
// 필요한 값 이라면 res 에 저장해서 사용함

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// 형 변환 연산자 : 연산 할 때 피 연산자의 형태가 다르면 자동으로 일치됨 eg) 정수 + 실수 -> 실수 + 실수 형태로 
// 형 변환 연산자는 피연산자의 값을 원하는 형태로 변환시켜줌. (일시적으로 그 연산 과정에서만 바꿔줌)
// (double)10 -> 10.0  정수를 실수로 바꾸는 경우 
// (int)10.7 -> 10  실수를 정수로 바꾸는 경우 

    // int a = 20 , b = 3;
    // double res;

    // res = ((double)a) / ((double)b); //(double)를 사용해 a 와 b의 값을 실수로 변환
    // printf("a = %d, b = %d\n", a, b);
    // printf(" a/ b 의 결과 : %.1f\n", res);

    // a = (int)res;           // (int)를 사용해 res의 값에서 정수 부분만 추림
    // printf("(int)%.1lf의 결과 : %d\n", res ,a);

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // sizeof 연산자 값은 byte 단위로 알려줌
//     int a = 10 ;
//     double b = 3.4;

//     printf("int형 변수의 크기 : %d\n", sizeof(a));
//     printf("double 변수의 크기 : %d\n", sizeof(b));
//     printf("정수형 상수의 크기 : %d\n", sizeof(10));
//     printf("수식의 결과값의의 크기 : %d\n", sizeof(1.5+3.4));
//     printf("char 자료형의 크기 : %d\n", sizeof(char));
//     printf("long형 변수의 크기 : %d\n", sizeof(long)); // linux 운영체제에서 long는 8바이트 ,, window 에서는 4바이트

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 복합대입연산자
//     int a = 10,b = 20 ;
//     int res = 2; 

//     a += 20;
//     res *= b+10; // b에 10을 더한 결과값에 res를 곱하고 다시 res에 저장 >> res = res*(b+10) 괄호로 쳐짐.

//     printf("a = %d, b = %d\n",a,b);
//     printf("res = %d\n", res);
//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 콤마 연산자
// int a = 10, b = 20;
// int res;

// res = (++a, ++b);
// printf("a:%d,b:%d\n",a,b);
// printf("res:%d\n",res);
// // res = 21 인 이유는 res의 칸은 하나인데 먼저 실행(전위연산)된 ++a(11)이 들어있다가 (,) 뒤로 ++b 가 실행(전위연산)되면서 21이 res 에 채워지면서 11(++a)값이 버려지기 때문임.

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 조건 연산자 
//     int a = 10 , b = 20 , res ;
//     res = (a>b) ? a : b; // a>b가 참이면 a 선택, 거짓이면 b 선택, (? 단순 참인지 물어보는 수식)->앞의 수식이 참인가 ? 참이라면 a 선택, (:그렇지않으면이라는 의미)-> 그렇지 않다면 b 선택
//     printf("큰 값 : %d\n", res); //만약  res(a<b)라면 , 10이 출력됨

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

// // 비트 연산자
//     int a =10; //1010
//     int b = 12; // 1100
//     printf("a & b : %d\n", a&b);  // (논리곱 연산자&) 연산할 때 둘다 1인것만 1로 출력 > 1010 & 1100 > 1000 > 8
//     printf("a ^ b : %d\n", a^b); // (배타적 논리합 연산자^) 둘 다 다를 때만 1이 출력 > 1010 ^ 1100 > 0110 > 6
//     printf("a | b : %d\n", a|b); // (논리 합 연산자|) or의 개념. 둘 중 1이 있으면 1 로 출력 > 1010 | 1100 > 1110 > 14
//     printf("~a : %d\n", ~a); // (부정 연산자~) 1과 0을 바꿈 >000..001010 > 111...110101 > 2의 보수(-1필요):111.110100> 1의보수로 변환 > 100...001011> - 11
//     printf("a << 1 : %d\n", a<<1); // 왼쪽 이동 연산자 : 왼쪽으로 1칸 밀고 빈 자리는 0으로 채움 : 1010 > 10100 > 16+4 = 20
//     printf("a >> 2 : %d\n", a>>2); // 오른쪽 이동 연산자 : 오른쪽으로 1칸 밀고 빈자리 0으로 채움 : 1010 > 0010 > 2 ,,, 8비트는 1바이트 ,int는 4바이트 최대32칸임
    
//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

    return 0;
}
